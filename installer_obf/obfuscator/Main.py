import ScrambledIpcCommand
import ScrambledString
import CodeSegment
import Services
import Crypto

### Initial vars
TEST = 0
code = []

### Encrypt hbl.nsp
hbl = open('build/hbl.pfs0', 'rb').read()
hbl += 'X' * ((0x1000 - (len(hbl) % 0x1000)) % 0x1000)

hbl_bin_size = len(hbl)
assert (hbl_bin_size % 0x1000) == 0

### Boilerplate
code.append(CodeSegment.Raw('''
#include <switch.h>
#include <string.h>
#include <arm_acle.h> // for crc intrinsics
#include <arm_neon.h> // for neon+crypto intrinsics

u32 __nx_applet_type = AppletType_None;

static char g_heap[0x20000];

void __libnx_initheap(void)
{
    extern char* fake_heap_start;
    extern char* fake_heap_end;

    fake_heap_start = &g_heap[0];
    fake_heap_end   = &g_heap[sizeof g_heap];
}

void __appInit(void)
{
    if (R_FAILED(smInitialize()))
        fatalSimple(MAKERESULT(Module_Libnx, LibnxError_InitFail_SM));
}

void threadfunc(void);

int main(int argc, char* argv[])
{
    static Thread t;
    Result rc;

    rc = threadCreate(&t, (ThreadFunc) &threadfunc, NULL, 0x4000, 0x28, 1);
    if (rc) fatalSimple(rc);

    rc = threadStart(&t);
    if (rc) fatalSimple(rc);

    svcExitThread();
}

void threadfunc(void) {
    Handle tmp_handle;
    Result rc;

'''))

srv = Services.Services()
code.append(srv)

### ipcDuplicateSession
for i in range(64):
    idx, idx_obf =srv.get_index('pm:shell')
    code.append(idx_obf)
    code.append(ScrambledIpcCommand.IpcCommand(srv.get_handle(idx), 2, cmd_type=5, raw=[0], ignore_error=True))

srv = Services.Services()
code.append(srv)

### fsGetPid
idx, idx_obf = srv.get_index('fsp-srv')
code.append(idx_obf)

code.append(
    CodeSegment.Combined(
        ScrambledIpcCommand.IpcCommand(srv.get_handle(idx), 1, raw=[0, 0], pid=True),
        CodeSegment.Raw('''u64 pid = ((u32*)armGetTls())[3];'''))
)

### fsprClearPerm
idx, idx_obf = srv.get_index('fsp-pr')
code.append(idx_obf)

code.append(ScrambledIpcCommand.IpcCommand(srv.get_handle(idx), 1, raw=['pid', 0]))

### fsprSetFullPerm
code.append(CodeSegment.Raw('''
    char b0[0x1c];
    memset(b0, 0, sizeof b0);
    *(u32*)(&b0[0]) = 1;
    *(u64*)(&b0[4]) = -1ull;
    *(u32*)(&b0[0x0C]) = sizeof b0;
    *(u32*)(&b0[0x14]) = sizeof b0;

    char b1[0x2c];
    memset(b1, 0, sizeof b1);
    *(u32*)(&b1[0]) = 1;
    *(u64*)(&b1[4]) = -1ull;
    *(u64*)(&b1[0x14]) = -1ull;
    *(u64*)(&b1[0x24]) = -1ull;
'''))

idx, idx_obf = srv.get_index('fsp-pr')
code.append(idx_obf)

code.append(ScrambledIpcCommand.IpcCommand(
    srv.get_handle(idx), 0, raw = [3, 0, 'pid', 0, 0x0000100A, 0x01000000, 0x1c, 0, 0x2c, 0], a = [['&b0[0]', 0x1c], ['&b1[0]', 0x2c]]
))

### fsInitialize
idx, idx_obf = srv.get_index('fsp-srv')
code.append(idx_obf)

code.append(ScrambledIpcCommand.IpcCommand(
    srv.get_handle(idx),
    1, raw = [0, 0], pid=True
))

### fsMountBis
code.append(CodeSegment.Raw('''
    char buf[300];
    buf[0] = 0;
'''))

idx, idx_obf = srv.get_index('fsp-srv')
code.append(idx_obf)

code.append(CodeSegment.Combined(
    ScrambledIpcCommand.IpcCommand(
        srv.get_handle(idx), 11, raw = [30, 0], x = [['&buf[0]', 300]]
    ),
    CodeSegment.Raw('''Handle nand_handle = ((u32*)armGetTls())[3];'''))
)

### fsFsDeleteFile
file_path = ScrambledString.ScrambledString('/.nsp', 300)
code.append(file_path)

code.append(ScrambledIpcCommand.IpcCommand(
    'nand_handle', 1, raw=[], x = [[file_path.get_var_name(), 300]],
    ignore_error=True
))


### fsFsCreateFile
code.append(ScrambledIpcCommand.IpcCommand(
    'nand_handle', 0, raw=[0, 0, hbl_bin_size, 0, 0], x = [[file_path.get_var_name(), 300]],
))

### fsFsOpenFile
code.append(CodeSegment.Combined(
    ScrambledIpcCommand.IpcCommand(
        'nand_handle', 8, raw=[2, 0], x = [[file_path.get_var_name(), 300]]),
    CodeSegment.Raw('''Handle file_handle = ((u32*)armGetTls())[3];'''))
)

### fsFileWrite
chunks = []

for offset in range(0, hbl_bin_size, 0x400):
    chunk = hbl[offset:offset+0x400]
    chunks.append({'enc': Crypto.Decryptor(chunk), 'offset': offset})

import random
random.shuffle(chunks)

for c in chunks:
    enc = c['enc']
    offset = c['offset']

    code.append(enc)
    code.append(ScrambledIpcCommand.IpcCommand(
        'file_handle', 1, raw=[0, 0, offset, 0, len(chunk), 0], a = [[enc.get_var_name(), len(chunk), 1]]
    ))

code.append(CodeSegment.Raw('''
    fatalSimple(MAKERESULT(0, 1337));
}
'''))

### Generate code
for c in code:
    print c.generate()
