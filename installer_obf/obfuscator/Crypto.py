import Random
import ScrambledString
import Variable
import Operators

import struct

def _strto4(s):
    return [_ for _ in struct.unpack('<IIII', s)]

# Implementation

class Decryptor:
    def __init__(self, data):
        key = []
        for i in range(4):
            key.append(Random.get_u32())

        self.key = key
        self.data = data
        self.var_name = Variable.alloc_name('chunk')

        if (len(data) % 32) != 0:
            raise NotImplementedError()

        self.op_types = []
        for i in range(64):
            self.op_types.append(Operators.get_random_op())

        self.encrypt_data()

    def encrypt_data(self):
        enc = ''
        dec = self.data

        k = self.key
        f = open('build/%s.h' % self.var_name, 'w')
        n = 0

        for i in range(len(dec)/8):
            chunk = dec[i*8 : i*8+8]
            chunk0 = struct.unpack('<I', chunk[:4])[0]
            chunk1 = struct.unpack('<I', chunk[4:])[0]

            for j, op in enumerate(self.op_types):
                if (j % 2) == 0:
                    chunk0 ^= op(chunk1, i*8).get_result()
                else:
                    chunk1 ^= op(chunk0, k[j%4]).get_result()

            out = struct.pack('<II', chunk0, chunk1)

            # Print C char array format
            for ch in out:
                f.write('0x%02x, ' % ord(ch))

                # Add newlines in the header file
                n+=1
                if (n%16) == 0:
                    f.write('\n')

    def get_var_name(self):
        return self.var_name

    def generate(self):
        ret = ''

        k = ScrambledString.ScrambledString(struct.pack('<IIII', self.key[0], self.key[1], self.key[2], self.key[3]), binary=True)
        ret += k.generate()

        ret += '''
    static char %s[] = {
#include "../build/%s.h"
    };
''' % (self.var_name, self.var_name)

        ret += '''
    for (int off=0; off<%d; off+=8) {
        u32* msg_32 = (u32*) (&%s[off]);
''' % (len(self.data), self.var_name)

        for j, op in enumerate(reversed(self.op_types)):
            if (j % 2) == 0:
                op = op('msg_32[0]', '((u32*)%s)[%d]' % (k.get_var_name(), 3-(j%4)))
            else:
                op = op('msg_32[1]', 'off')
            ret += op.generate_code()

            if (j % 2) == 0:
                ret += 'msg_32[1] ^= %s;\n' % op.get_var_name()
            else:
                ret += 'msg_32[0] ^= %s;\n' % op.get_var_name()

        ret += '''
    }
'''

        return ret
