#!/usr/bin/python2
#from __future__ import print_function
from unicorn import *
from unicorn.arm64_const import *
import sys
import struct

CODE_BASE = 0xA0000000
MAIN_BASE = 0xA0000000+0x4000

def hexdump(src, length=16):
    FILTER = ''.join([(len(repr(chr(x))) == 3) and chr(x) or '.' for x in range(256)])
    lines = []
    for c in xrange(0, len(src), length):
        chars = src[c:c+length]
        hex = ' '.join(["%02x" % ord(x) for x in chars])
        printable = ''.join(["%s" % ((ord(x) <= 127 and FILTER[ord(x)]) or '.') for x in chars])
        lines.append("%04x  %-*s  %s\n" % (c, length*3, hex, printable))
    return ''.join(lines)

def dump(mu, addr, sz):
    mem = mu.mem_read(addr, sz)
    mem = ''.join(chr(m) for m in mem)
    print hexdump(mem)

def regs(mu):
    print '____'
    print ''
    print ''
    print "X0  = 0x%x" % mu.reg_read(UC_ARM64_REG_X0)
    print "X1  = 0x%x" % mu.reg_read(UC_ARM64_REG_X1)
    print "X2  = 0x%x" % mu.reg_read(UC_ARM64_REG_X2)
    print "X3  = 0x%x" % mu.reg_read(UC_ARM64_REG_X3)
    print "X4  = 0x%x" % mu.reg_read(UC_ARM64_REG_X4)
    print "X5  = 0x%x" % mu.reg_read(UC_ARM64_REG_X5)
    print "X6  = 0x%x" % mu.reg_read(UC_ARM64_REG_X6)
    print "X7  = 0x%x" % mu.reg_read(UC_ARM64_REG_X7)
    print "X8  = 0x%x" % mu.reg_read(UC_ARM64_REG_X8)
    print "X9  = 0x%x" % mu.reg_read(UC_ARM64_REG_X9)
    print "X10 = 0x%x" % mu.reg_read(UC_ARM64_REG_X10)
    print "X11 = 0x%x" % mu.reg_read(UC_ARM64_REG_X11)
    print "X12 = 0x%x" % mu.reg_read(UC_ARM64_REG_X12)
    print "X13 = 0x%x" % mu.reg_read(UC_ARM64_REG_X13)
    print "X14 = 0x%x" % mu.reg_read(UC_ARM64_REG_X14)
    print "X15 = 0x%x" % mu.reg_read(UC_ARM64_REG_X15)
    print "X16 = 0x%x" % mu.reg_read(UC_ARM64_REG_X16)
    print "X17 = 0x%x" % mu.reg_read(UC_ARM64_REG_X17)
    print "X18 = 0x%x" % mu.reg_read(UC_ARM64_REG_X18)
    print "X19 = 0x%x" % mu.reg_read(UC_ARM64_REG_X19)
    print "X20 = 0x%x" % mu.reg_read(UC_ARM64_REG_X20)
    print "X21 = 0x%x" % mu.reg_read(UC_ARM64_REG_X21)
    print "X22 = 0x%x" % mu.reg_read(UC_ARM64_REG_X22)
    print "X23 = 0x%x" % mu.reg_read(UC_ARM64_REG_X23)
    print "X24 = 0x%x" % mu.reg_read(UC_ARM64_REG_X24)
    print "X25 = 0x%x" % mu.reg_read(UC_ARM64_REG_X25)
    print "X26 = 0x%x" % mu.reg_read(UC_ARM64_REG_X26)
    print "X27 = 0x%x" % mu.reg_read(UC_ARM64_REG_X27)
    print "X28 = 0x%x" % mu.reg_read(UC_ARM64_REG_X28)
    print "X29 = 0x%x" % mu.reg_read(UC_ARM64_REG_X29)
    print "X30 = 0x%x" % mu.reg_read(UC_ARM64_REG_X30)
    print "PC  = 0x%x" % mu.reg_read(UC_ARM64_REG_PC)
    print "SP  = 0x%x" % mu.reg_read(UC_ARM64_REG_SP)

def hook(uc):
    pc = mu.reg_read(UC_ARM64_REG_PC)
    x0 = mu.reg_read(UC_ARM64_REG_X0)
    x1 = mu.reg_read(UC_ARM64_REG_X1)

    # smGetService
    if pc == (MAIN_BASE + 0x3DC674+4+8):
        print 'smGetService'
        mu.mem_write(x0, '\x13\x37\x00\x00')
        mu.reg_write(UC_ARM64_REG_PC, MAIN_BASE + 0x3DC6A0)
        mu.reg_write(UC_ARM64_REG_X0, 0)
        #sys.stdin.read(1)
    # svcSendSyncRequestWithUserBuffer
    elif pc == (MAIN_BASE + 0x3ED3DC):
        print 'svcSendSyncRequestWithUserBuffer'
        dump(mu, CODE_BASE+0x3000, 0x80)
        dump(mu, MAIN_BASE+0x8AC000, 0x80)
        mu.reg_write(UC_ARM64_REG_PC, MAIN_BASE + 0x3ED3DC+4)
        #sys.stdin.read(1)
    # infloop
    elif pc == (CODE_BASE + 0xAC):
        print 'INFLOOP'
        sys.exit(0)
    elif pc == 0xfffffff7ffc39880:
        print 'WRITEEEEEEEEEEEEEE %x' % x0
        if x0 == 0xa1000000:
            mu.reg_write(UC_ARM64_REG_PC, 0xfffffff7ffc39884)

def hook_code(uc, address, size, user_data):
    hook(uc)

mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM | UC_MODE_LITTLE_ENDIAN)

kernel_base = 0xFFFFFFF7FFC00000
kernel = open('test/v3.0_.text_0xFFFFFFF7FFC00000.bin', 'rb').read()

mu.mem_map(kernel_base, len(kernel))
mu.mem_write(kernel_base, kernel)

code_base = CODE_BASE
code_size = 0x9cb000
mu.mem_map(code_base, code_size)

rtld = open('test/rtld_text.bin', 'rb').read()
mu.mem_write(code_base, rtld)
rtld = open('test/rtld_rodata.bin', 'rb').read()
mu.mem_write(code_base+0x2000, rtld)
rtld = open('test/rtld_data.bin', 'rb').read()
mu.mem_write(code_base+0x3000, rtld)

main = open('test/main_text.bin', 'rb').read()
mu.mem_write(code_base+0x4000, main)
main = open('test/main_rodata.bin', 'rb').read()
mu.mem_write(code_base+0x4000+0x5e3000, main)
main = open('test/main_data.bin', 'rb').read()
mu.mem_write(code_base+0x4000+0x5e3000+0x2c5000, main)

rop_base = 0x30000000
rop = open(sys.argv[1], 'rb').read()
rop_relocs = open(sys.argv[2], 'rb').read()

for i in range(len(rop_relocs)/8):
    t, r = struct.unpack('<II', rop_relocs[i*8:i*8+8])

    before    = rop[:r]
    inbetween = rop[r:r+8]
    after     = rop[r+8:]

    inbetween = struct.unpack('<Q', inbetween)[0]
    if t == 0:
        inbetween += rop_base
    elif t == 1:
        inbetween += code_base
    else:
        pass#raise Exception('Unknown relocation type')
    inbetween = struct.pack('<Q', inbetween)

    rop = before + inbetween + after

mu.mem_map(rop_base, (len(rop) + 0xFFF) &~ 0xFFF)
mu.mem_write(rop_base, rop)

#mu.hook_add(UC_HOOK_BLOCK, hook_block)
#mu.hook_add(UC_HOOK_CODE,  hook_code, begin=kernel_base, end=kernel_base)
mu.hook_add(UC_HOOK_CODE,  hook_code)

mu.reg_write(UC_ARM64_REG_SP, rop_base)
try:
    mu.emu_start(0xFFFFFFF7FFC00000+0x3a370, 0)
except:
    regs(mu)
    raise
