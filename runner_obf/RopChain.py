import Gadgets
import Sequences
import ImmEncoder
import struct
import random

class Chain:
    def __init__(self):
        self.chain = []
        self.data = []

    def add(self, seq):
        self.chain.append(seq)

    def add_data(self, data):
        data_idx = len(self.data)

        for i in range(len(data)):
            if isinstance(data[i], Gadgets.DataReferenceRelative):
                data[i] = Gadgets.DataReference(8*data_idx + data[i].rel)

        self.data += data
        return Gadgets.DataReference(8*data_idx)

    def emit(self, fn, fn_relocs):
        f = open(fn, 'wb')

        # Chain together all sequences
        output = []

        prev_seq = None
        for seq in self.chain:
            if prev_seq is None:
                prev_seq = seq
                continue

            x29 = Gadgets.DontCare()
            x30 = seq.get_addr()

            for g in prev_seq.generate(x29, x30):
                output += [g]

            prev_seq = seq

        # Add final sequence
        x29 = Gadgets.DontCare()
        x30 = Gadgets.DontCare()

        for g in prev_seq.generate(x29, x30):
            output += [g]

        # Save StartOfData
        data_off = len(output) * 8

        # Add data
        for g in self.data:
            output += [g]

        # Fixup relative references
        for i in range(len(output)):
            if isinstance(output[i], Gadgets.RelativeReference):
                output[i] = Gadgets.RopGadget(8*i + output[i].rel)

        # Fixup references
        targets = {}
        for n, g in enumerate(output):
            if isinstance(g, Gadgets.Gadget) and g.is_referenced:
                targets[g] = n

        for g in output:
            if isinstance(g, Gadgets.DataReference):
                g.set_data_offset(data_off)
            if isinstance(g, Gadgets.PlaceholderReference):
                g.set_placeholder_offset( 8*targets[g.placeholder] )
                
        print output

        for i in range(len(output)):
            if isinstance(output[i], Gadgets.DontCare):
                r = random.choice(output)
                while isinstance(r, Gadgets.DontCare):
                    r = random.choice(output)
                output[i] = r

        # Generate relocations
        relocs = []
        n = 0
        for g in output:
            relocs += g.generate_relocs(n)
            n += 1

        for i in range(len(output)):
            output[i] = output[i].get_value()

        # Emit entire krop
        f.write(''.join(output))

        # Emit relocations
        f = open(fn_relocs, 'wb')

        for r in relocs:
            f.write(struct.pack('<I', r))
