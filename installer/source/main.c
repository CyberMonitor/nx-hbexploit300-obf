#include <switch.h>
#include <string.h>
#include <arm_neon.h>
#include "loader_bin.h"

u32 __nx_applet_type = AppletType_None;

static char g_heap[0x20000];

void __libnx_initheap(void)
{
    extern char* fake_heap_start;
    extern char* fake_heap_end;

    fake_heap_start = &g_heap[0];
    fake_heap_end   = &g_heap[sizeof g_heap];
}

void ipcDuplicateSession(Service* s)
{
    u32* buf = (u32*)armGetTls();

    buf[0] = 5;
    buf[1] = 8;
    buf[4] = SFCI_MAGIC;
    buf[5] = 0;
    buf[6] = 2;
    buf[7] = 0;

    ipcDispatch(s->handle);
}

Result fsGetPid(Service* s, u64* pid_out)
{
    Result rc;

    IpcCommand c;
    ipcInitialize(&c);
    ipcSendPid(&c);

    struct {
        u64 magic;
        u64 cmd_id;
        u64 unk;
    } *raw;

    raw = ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 1;
    raw->unk = 0;

    rc = serviceIpcDispatch(s);

    if (R_SUCCEEDED(rc)) {
        *pid_out = ((u32*)armGetTls())[3];
    }

    return rc;
}

Result fsprClearPerm(Service* s, u64 pid)
{
    IpcCommand c;
    ipcInitialize(&c);

    struct {
        u64 magic;
        u64 cmd_id;
        u64 pid;
    } *raw;

    raw = ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 1;
    raw->pid = pid;

    return serviceIpcDispatch(s);
}

Result fsprSetFullPerm(Service* s, u64 pid)
{
    char b0[0x1c];
    memset(b0, 0, sizeof b0);
    *(u32*)(&b0[0]) = 1;
    *(u64*)(&b0[4]) = -1ull;
    *(u32*)(&b0[0x0C]) = sizeof b0;
    *(u32*)(&b0[0x14]) = sizeof b0;

    char b1[0x2c];
    memset(b1, 0, sizeof b1);
    *(u32*)(&b1[0]) = 1;
    *(u64*)(&b1[4]) = -1ull;
    *(u64*)(&b1[0x14]) = -1ull;
    *(u64*)(&b1[0x24]) = -1ull;

    IpcCommand c;
    ipcInitialize(&c);
    ipcAddSendBuffer(&c, b0, sizeof b0, 0);
    ipcAddSendBuffer(&c, b1, sizeof b1, 0);

    struct {
        u64 magic;
        u64 cmd_id;
        u64 storage_id;
        u64 pid;
        u64 title_id;
        u64 b0_size;
        u64 b1_size;
    } *raw;

    raw = ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 0;
    raw->storage_id = 3;
    raw->pid = pid;
    raw->title_id = 0x010000000000100A;
    raw->b0_size = sizeof b0;
    raw->b1_size = sizeof b1;

    return serviceIpcDispatch(s);
}

Result fsMountBis(Service* s, u32 partition_id, FsFileSystem* fs_out)
{
    Result rc;

    char buf[300];
    buf[0] = '\0';

    IpcCommand c;
    ipcInitialize(&c);
    ipcAddSendStatic(&c, buf, sizeof buf, 0);

    struct {
        u64 magic;
        u64 cmd_id;
        u64 partition_id;
    } *raw;

    raw = ipcPrepareHeader(&c, sizeof(*raw));

    raw->magic = SFCI_MAGIC;
    raw->cmd_id = 11;
    raw->partition_id = partition_id;

    rc = serviceIpcDispatch(s);

    if (R_SUCCEEDED(rc)) {
        IpcParsedCommand r;
        ipcParse(&r);

        struct {
            u64 magic;
            u64 result;
        } *resp = r.Raw;

        rc = resp->result;

        if (R_SUCCEEDED(rc)) {
            fs_out->h = r.Handles[0];
        }
    }

    return rc;
}

void __appInit(void)
{
    if (R_FAILED(smInitialize()))
        fatalSimple(MAKERESULT(Module_Libnx, LibnxError_InitFail_SM));
}

int main(int argc, char **argv)
{
    Result rc;
    Service pm_shell;
    rc = smGetService(&pm_shell, "pm:shell");
    if (rc) fatalSimple(MAKERESULT(349, 1));

    int i;
    for(i=0; i<256; i++)
        ipcDuplicateSession(&pm_shell);

    Service fsp_srv;
    rc = smGetService(&fsp_srv, "fsp-srv");
    if (rc) fatalSimple(MAKERESULT(349, 2));

    u64 pid;
    rc = fsGetPid(&fsp_srv, &pid);
    if (rc) fatalSimple(MAKERESULT(349, 3));

    serviceClose(&fsp_srv);

    Service fsp_pr;
    rc = smGetService(&fsp_pr, "fsp-pr");
    if (rc) fatalSimple(MAKERESULT(349, 4));

    rc = fsprClearPerm(&fsp_pr, pid);
    if (rc) fatalSimple(MAKERESULT(349, 5));

    rc = fsprSetFullPerm(&fsp_pr, pid);
    if (rc) fatalSimple(rc);

    rc = fsInitialize();
    if (rc) fatalSimple(MAKERESULT(349, 7));

    FsFileSystem fs_nand;
    rc = fsMountBis(fsGetServiceSession(), 30, &fs_nand);
    if (rc) fatalSimple(rc);

    rc = fsFsDeleteFile(&fs_nand, "/hbl.nsp");

    rc = fsFsCreateFile(&fs_nand, "/hbl.nsp", hbl_bin_size, 0 /* flags */);
    if (rc) fatalSimple(MAKERESULT(349, 9));

    FsFile f;
    rc = fsFsOpenFile(&fs_nand, "/hbl.nsp", FS_OPEN_WRITE /* flags */, &f);
    if (rc) fatalSimple(MAKERESULT(349, 10));

    rc = fsFileWrite(&f, 0, hbl_bin, hbl_bin_size);
    if (rc) fatalSimple(MAKERESULT(349, 11));

    fatalSimple(MAKERESULT(0, 1337));
    return 0;
}
